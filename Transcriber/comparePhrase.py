import cPickle as pickle
import operator


def findCompletePhrase(phrase1, phrase2):
	if phrase1 in phrase2:
		return phrase2, None
	else:
		return phrase1, phrase2

## get rid of incomplete duplicate phrases generated by cc
## keeps only the longest, most complete version of each phrase
rawSRT = pickle.load( open("speech.p","r"))
speech = []
for p in rawSRT:
	speech.append(p)
	if len(speech) >= 2:
		phrase2 = speech.pop()
		phrase1 = speech.pop()
		fullPhrase, lastPhrase= findCompletePhrase(phrase1, phrase2)
		if lastPhrase is not None:
			speech.append(fullPhrase)
			speech.append(lastPhrase)
		else:
			speech.append(fullPhrase)
				#print phrase2
		#print phrase1
	else: 
		pass

### Make the composite phrase into the new "1st phrase" of the next comparison

sub_speech = speech[0: len(speech)]
clean_speech = []
iter_count = 0

sub_speech.reverse()

for phrase in sub_speech:
	if ((phrase != ' ') and (phrase != '')):
		clean_speech.append(phrase)
		iter_count += 1
	if ( len(clean_speech) == 2):
		phraseA = clean_speech.pop().split()
		# print "Phrase A: ", phraseA
		phraseB = clean_speech.pop().split()
		# print "Phrase B: ", phraseB
		composite_phrase = []

		#iron clad error checking
		matchIndex = []
		searchSegment = []
		if (len(phraseB) >= 1) and (len(phraseA) >= 1):
			searchSegment = phraseA[-len(phraseB)::]
			for i, token in enumerate(searchSegment):
				if token == phraseB[0]:
					matchIndex.append(i)
			# print "Phrase pair is", searchSegment, phraseB
			if len(matchIndex) == 0:
				composite_phrase = phraseA + phraseB
			if len(matchIndex) == 1:
				# print matchIndex[0]
				# print len(phraseA) - len(phraseB) + matchIndex[0] + 1
				# print "nonduplicate section is",searchSegment[0:matchIndex[0]]
				composite_phrase = phraseA[0:-len(phraseB)] + searchSegment[0:matchIndex[0]] + phraseB
			elif len(matchIndex) > 1:
				IndexMatchCounter = dict.fromkeys(matchIndex, 0)
				# print "IndexMatchCounter: ",IndexMatchCounter
				for i in matchIndex:
					postMatchSegment = searchSegment[i:]
					for j, token in enumerate(searchSegment[i:]):
						if token == phraseB[j]:
							IndexMatchCounter[i] += 1               
				# print IndexMatchCounter
				trueIndex = max(IndexMatchCounter.iteritems(), key=operator.itemgetter(1))[0]
				# print trueIndex
				composite_phrase = phraseA[0:-len(phraseB)] + searchSegment[0:trueIndex] + phraseB
			# print "Composite is", composite_phrase
			clean_speech.append(" ".join(composite_phrase))
	# 	count = 0
	# 	tmp_count = 0
	# 	found = False
	# 	if (len(phraseA) >= 1) and (len(phraseB) >= 1):
	# 		search_len = len(phraseB)
	# 		### we don't care about matches that are longer than the second phrase, so restrict the searchable area to the length of the second 
	# 		### phrase max
	# 		if (len(phraseA) >= search_len):
	# 			partial_phrase = phraseA[len(phraseA) - search_len: len(phraseA)]
	# 		else:
	# 			partial_phrase = phraseA
	# 		### search backwards from the end of the partial_phrase
	# 		for token in reversed(partial_phrase):
	# 			count += 1
	# 			if token == phraseB[0]:
	# 				found = True
	# 				### if the first word checked is a match, no need to apply the error checks below
	# 				if count == 1:
	# 					break
	# 				### when you find a match, ensure there is not actual intended repetition in the speech by
	# 				### checking to see if the word after the first of the second phrase matches the word after the 
	# 				### found match
	# 				if partial_phrase[len(partial_phrase) - count + 1] == phraseB[1]:
	# 					break
	# 		### The composite phrase will hold only the non-repeated segments of both phrases
	# 		if found: composite_phrase = phraseA[0:len(phraseA) - count] + phraseB
	# 		### When there is no match, simply append both complete phrases together
	# 		else: composite_phrase = phraseA + phraseB
	# 		# print "Composite Phrase: ", " ".join(composite_phrase)
	# 	clean_speech.append(" ".join(composite_phrase))
	# print "iter_count: ", iter_count

print clean_speech


