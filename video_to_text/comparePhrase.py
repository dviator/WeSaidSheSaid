import cPickle as pickle


def findCompletePhrase(phrase1, phrase2):
	if phrase1 in phrase2:
		return phrase2, None
	else:
		return phrase1, phrase2

## get rid of incomplete duplicate phrases generated by cc
## keeps only the longest, most complete version of each phrase
rawSRT = pickle.load( open("speech.p","r"))
speech = []
for p in rawSRT:
	speech.append(p)
	if len(speech) >= 2:
		phrase2 = speech.pop()
		phrase1 = speech.pop()
		fullPhrase, lastPhrase= findCompletePhrase(phrase1, phrase2)
		if lastPhrase is not None:
			speech.append(fullPhrase)
			speech.append(lastPhrase)
		else:
			speech.append(fullPhrase)
				#print phrase2
		#print phrase1
	else: 
		pass

## complete phrases shift and repeat themselves, and so we want to 
## elminiate duplicate overlapping portions of each phrase
cleanSpeech = []
# for p in speech:
# 	cleanSpeech.append(p)
# 	if len(cleanSpeech) >= 2:
# 		phrase2 = cleanSpeech.pop().split()
# 		phrase1 = cleanSpeech.pop().split()
# 		print phrase1, phrase2
# 	#Not working yet
# 	for x in phrase2:
# 		if x not in phrase1:
# 			cleanSpeech.append(x)

speech_recurse_1 = []
speech_recurse_2 = []
speech_recurse_3 = []

for phrase in speech:
	phraseA = speech.pop().split()
	phraseB = speech.pop().split()
	composite_phrase = []
	count = 0
	tmp_count = 0
	flag = False
	if (len(phraseA) > 1) and (len(phraseB) > 1):
		for token in reversed(phraseB):
			count += 1
			if token == phraseA[0]:
				tmp_count = count
				if flag == True:
					break
				flag = True
		composite_phrase = phraseB[0:len(phraseB) - tmp_count] + phraseA
	speech_recurse_1.append(" ".join(composite_phrase))

for phrase in speech_recurse_1:
	phraseB = speech_recurse_1.pop().split()
	phraseA = speech_recurse_1.pop().split()
	composite_phrase = []
	count = 0
	tmp_count = 0
	flag = False
	if (len(phraseA) > 1) and (len(phraseB) > 1):
		for token in reversed(phraseB):
			count += 1
			if token == phraseA[0]:
				tmp_count = count
				if flag == True:
					break
				flag = True
		composite_phrase = phraseB[0:len(phraseB) - tmp_count] + phraseA
	speech_recurse_2.append(" ".join(composite_phrase))

for phrase in speech_recurse_2:
	phraseA = speech_recurse_2.pop().split()
	phraseB = speech_recurse_2.pop().split()
	composite_phrase = []
	count = 0
	tmp_count = 0
	flag = False
	if (len(phraseA) > 1) and (len(phraseB) > 1):
		for token in reversed(phraseB):
			count += 1
			if token == phraseA[0]:
				tmp_count = count
				if flag == True:
					break
				flag = True
		composite_phrase = phraseB[0:len(phraseB) - tmp_count] + phraseA
	speech_recurse_3.append(" ".join(composite_phrase))

print speech_recurse_3


# for i in range(1,30):
# 	tmp = speech.pop()
	

# test0 = speech.pop().split()
# test1 = speech.pop().split()
# test_composite = []

# print test1
# print test0

# count = 0
# for token in test1:
# 	count += 1
# 	if token == test0[0]:
# 		print count
# 		print "found a match!\n"
# 		test_composite = test1[0:count - 1] + test0
# 		print test_composite
# 		break


#print findCompletePhrase("Americans", "All Americans")
#print findCompletePhrase("All Americans", "All Americans are")
#print findCompletePhrase("All Americans are", "really really beautiful")

